7/24

<테이블 생성>
create table <테이블 이름> (<필드리스트>)
-> 필드 리스트는 필드명 데이터타입
- 기본키, 외래키 설정
테이블을 생성할 기본키 역할을 하는 필드를 지정
ex) varchar(10), varchar(20) not null (해당 필드에 null을 허용하지 않는다는 것을 의미함)
constraint pk_department primary key(dept_id)

<테이블 삭제>
drop table <테이블이름>
주의사항 -> 다른 테이블에서 외래키로 참조되는 경우에는 삭제할 수 없음.

- 테이블 수정 -> 기존 테이블에 새로운 필드를 추가하거나 기존 필드를 삭제
alter table <테이블이름> add <추가할필드>
삭제하면 alter table <테이블이름> drop column <삭제할필드>

기본키, 외래키 관련 주의사항
외래키를 필드로 갖는 데이블을 생성할 때 -> 외래키가 참조하는 테이블을 먼저 생성

ex) dept 테이블은 member 테이블을 외래키로 참조하였다.
그러면 dept 테이블을 삭제하려면 member 테이블을 먼저 삭제하든지, 외래키를 해제해야 함.

- 레코드 삽입
insert into <테이블이름> (<필드리스트>) values (<값리스트>)
<필드리스트> 삽입에 사용될 테이블의 필드들
<값리스트> <필드리스트>의 순서에 맞춰 삽입될 값
삽입 명령문에 필드 이름을 나영할 경우 그 순서는 테이블을 생성할 때 지정한 순서와 반드시 일치할 필요는 없음.
not null로 설정된 필드는 널값이 들어갈 수 없는 필드이기 때문에 insert문의 <필드리스트>에서 생략할 수 없음.

-레코드 수정
  update <테이블이름>
  set <수정내역>
  where <조건>

  <수정내역> 
   대상 테이블의 필드에 들어가는 값을 수정하기 위한 산술식
   ','를 이용해서 여러 필드에 대한 수정 내역을 지정

  <조건>
    대상이 되는 레코드에 대한 조건을 기술
    관계대수에서 선택 연산의 조건식과 같은 의미
    테이블의 모든 레코드에 대해 수정을 적용하려면 where 절을 생략

-레코드 삭제
  delete from <테이블이름>
  where <조건>

  where절에 지정된 조건을 만족하는 레코드를 삭제
  where절이 생략되면 테이블에서 모든 레코드를 삭제
  테이블은 삭제되지 않음.

-레코드 삽입 시 주의사항
  외래키로 사용되는 필드에 대해 데이터를 삽입할 때
	참조하는 테이블의 해당 필드에 그 값을 먼저 삽입해야 함

  외래키로 사용되는 필드의 값을 수정할 때
	외래키가 참조하는 테이블에 삽입되어 있는 값으로만 수정이 가능
  외래키로 참조되는 필드를 가지고 있는 테이블에서 레코드를 삭제할 경우에도 오류가 발생할 수 있음.


<레코드 검색> -> 가장 많이 사용하고, 중요하며, 복잡함.

select <필드리스트>
from <테이블리스트>
where <조건>

select -> 질의 결과로 출력할 필드들의 리스트, 관계대수의 추출연산에
from -> 질의 실행과정에 필요한 테이블들의 리스트를, 관계대수의 카티션 프로덕트
where -> 검색되어야 하는 레코드에 대한 조건, 관계대수의 선택연산에서 생략 가능

	중복된 레코드를 제거하고 검색하려면 distinct를 사용
	from 절에 나타난 테이블 모든 필드의 값을 추출할 경우에는 select 절에 모든 필드를 명시할 필요 없이 '*'를 사용
	select절에 필드이름 외에 산술식이나 상수의 사용이 가능
	from 절에 두 개 이상의 테이블이 포함된 질의

<레코드의 순서 지정 (order by)>
	검색 결과를 정렬하여 출력하는 기능
	select문 맨 마지막에 다음과 같은 order by절을 추가
	order by <필드리스트>
		오름차순을 기본으로 하며 <필드리스트>에 여러 개의 필드를 나열할 경우 나열된 순서대로 정렬
	내림차순은 해당 필드 이름 뒤에 desc 라는 키워드를 삽입

<재명명 연산>
테이블이나 필드에 대한 재명명
	실제 테이블 이름이 수정되거나 필드 이름이 바뀌는 것이 아님
	질의를 처리하는 과정 동안만 일시적으로 사용
	표현이 단순화하거나, 동일 이름이 존재할 경우에 사용
	동일 테이블이 두 번 사용됨.

<필드의 재명명>
	질의 실행 결과를 출력할 때 원래 필드의 이름 대신 재명명된 이름으로 출력시키고자 할 때 사용

<Like 연산자>
	where <필드이름> like <문자열패턴> -> 필드이름에 지정된 문자열패턴이 들어있는지를 판단
	문자열에 대해서는 일부분만 일치하는 경우를 찾아야 할 때 사용
	'=' 연산자 대신 like 연산자를 이용하는데 '='는 정확히 일치할 때만 사용함.
	'서울%', '___'가 좋은 예시이다.

<집합연산>
union, intersect, minus
<select문 1> <집합연산자> <select문 2> -> <select문 1>과 <select문 2>의 필드의 개수와 데이터타입이 서로 같아야 함.

<외부 조인 (outer join)>
강좌로 개설된 적이 있는 교과목에 대해서만 검색됨.

<집계 함수 (aggregate function)>
통계연산 기능 제공

count, sum, avg, max, min
	select 절과 having절에서만 사용가능
	sum, avg는 숫자형 데이터 타입을 갖는 필드에만 적용가능

- count(distinct <필드이름>)
	해당 필드에 값이 몇 개인지 출력
	distinct: 서로 구별되는 값의 개수가 필요한 경우에만 사용
	null은 계산에서 제외됨
	단, <필드이름>에는 필드 이름 대신 '*'가 사용된 경우에는 레코드의 개수를 계산
	distinct 키워드를 사용하면 중복되는 데이터를 제외한 개수를 리턴
- sum(<필드이름>)
- avg(<필드이름>)
- max(<필드이름>)
- min(<필드이름>)

<group by>
	select 절에 집계 함수가 사용될 경우 다른 필드는 select 절에 사용할 수 없음
	group by를 이용하면 그룹별로 집계합수 적용 가능
group by <필드리스트>
	group by 절은 select문에서 where절 다음에 위치
	group by에 지정된 필드의 값이 같은 레코드들끼리 그룹을 지어 각 그룹별로 집계 함수를 적용할 결과를 출력
	group by 절에 사용된 필드를 select 절에 추가하여 사용할 수 있음.